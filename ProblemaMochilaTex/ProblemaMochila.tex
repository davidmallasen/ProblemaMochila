\documentclass[12pt, a4paper]{article}

%Esto es para poder escribir acentos directamente:
\usepackage[latin1]{inputenc}
%Esto es para que el LaTeX sepa que el texto está en español:
\usepackage[spanish]{babel}

%Paquetes de la AMS:
\usepackage{amsmath}
\usepackage{amsfonts}

%Para añadir código
\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}

\lstset{
	language = C++,
	frame = single,
	basicstyle=\scriptsize,
	commentstyle=\color{mygreen},
	numbers=left,
	numberstyle=\tiny\color{mygray},
	keywordstyle=\color{blue},
	morekeywords={std, vector, sort, greater, size_t}
}

%Definiciones
\newcommand{\talque}{\text{ tal que }}

\newcommand{\twopartdef}[4]{
	\left\{
	\begin{array}{ll}
		#1 & \mbox{si } #2 \\
		#3 & \mbox{si } #4 \\
	\end{array}
	\right.
}

%Cabecera --------------------------------------
\title{El problema de la mochila}
\author{David Mallasén Quintana}
\date{}

\begin{document}
	
\maketitle

\begin{abstract}
	Implementación y comparación de diferentes algoritmos para resolver el problema de la mochila en sus distintas variantes. Se incluye una introducción al problema y el código de las resoluciones en C++.
\end{abstract}

\tableofcontents

%Cuerpo ----------------------------------------

\section{Introducción}

\subsection{Descripción del problema y variantes}

El problema de la mochila es un problema de optimización combinatoria, es decir, que busca la mejor solución entre un conjunto finito de posibles soluciones. Supondremos que tenemos una mochila con un peso limitado y que queremos llenarla con una serie de objetos dados por su peso y su valor. El objetivo del problema será maximizar el valor total de los objetos que metamos en la mochila sin exceder su peso máximo.\\

Es uno de los 21 problemas NP-completos de Richard Karp, lista elaborada en 1972 y perteneciente a su trabajo "Reducibility Among Combinatorial Problems". Esto surgió como profundización del trabajo de Stephen Cook, quien en 1971 había demostrado uno de los resultados más importantes y pioneros de la complejidad computacional: la NP-completitud del Problema de satisfacibilidad booleana (SAT). El descubrimiento de Karp de que todos estos importantes problemas eran NP-completos motivó el estudio de la NP-completitud y de la indagación en la famosa pregunta de si $P=NP$.

\subsubsection{Definición formal del problema}
Supongamos que tenemos $n$ objetos numerados del $1$ al $n$, cada uno con un peso $p_i > 0$ y un valor $v_i > 0$ para cada $i \in \{1 \dots n\}$. Tendremos también una mochila que soporta un peso máximo $M > 0$.\\

Definimos la función $x_i \in \{0, 1\}$ que indicará si se ha cogido el objeto $i$ ($x_i = 1$) o no ($x_i = 0$). El problema consiste en maximizar \[\sum_{i=1}^{n} v_i x_i\] con la restricción de $\sum_{i=1}^{n} p_i x_i < M$. La solución del problema vendrá dada por el conjunto de las $x_i$.\\

El caso en el que todos los objetos caben juntos en la mochila no tiene mucho interés ya que la solución consistiría en añadirlos s. Por tanto consideraremos el caso en el que $\sum_{i=1}^{n} p_i > M$.\\

Para el método voraz que veremos en la sección \ref{sec:voraz} tomaremos la variante en que los objetos se pueden fraccionar. En este caso siempre obtendremos una solución óptima, lo demostraremos en \ref{sec:demOptVoraz}, en la que $\sum_{i=1}^{n} p_i x_i = M$.

\subsection{Desarrollo de los casos de prueba}

\section{Implementación de los algoritmos}

\subsection{Método voraz} \label{sec:voraz}

En este apartado implementaremos una solución voraz al problema de la mochila. En el caso del método voraz obtendremos una solución de forma muy eficiente ($O(n\log n)$). Sin embargo tendremos que imponer la restricción de que los objetos sean fraccionables para que podamos asegurar una solución óptima.

\subsubsection{Descripción de la solución}

Primero ordenaremos los objetos según su densidad $d_i = \frac{v_i}{p_i}$. A la hora de construir la solución iremos cogiendo los objetos enteros en orden decreciente de densidad mientras quepan. Finalmente, si sobra hueco, fraccionaremos el objeto de mayor densidad que nos quede para terminar de rellenar toda la mochila.

\subsubsection{Demostración de optimalidad} \label{sec:demOptVoraz}

Sea $X=(x_1,\dots,x_n)$ la solución construida por el algoritmo voraz como hemos indicado anteriormente. Como hemos supuesto al principio que $\sum_{i=1}^{n} p_i > M$,  $\exists j \in \{1,\dots,n\} \talque x_j < 1$. Por la forma en la que construimos la solución sabemos que $0 \leq x_j < 1$ y $x_i = \twopartdef{1}{i < j}{0}{i > j}$. Supongamos que la solución $X$ no es óptima y procedamos mediante el método de reducción de diferencias. Comparamos con una solución óptima $Y = (y_1,\dots,y_n)$. \\

Sea $k = \min \{i:y_i \neq x_i\}$. Por como funciona el algoritmo se debe cumplir que $k \leq j$, veamos que $y_k < x_k$:
\begin{itemize}
	\item Si \underline{$k < j$}: $x_k = 1$ y, por tanto, $y_k < x_k$.
	\item Si \underline{$k = j$}: $y_i = 1$ para $1 \leq i < k$ por lo que $y_k > x_k$ implicaría $\sum_{i=1}^{n} p_i y_i > M$, cosa que no puede suceder. Por como hemos elegido $k$, $y_k \neq x_k$, luego debe ser $y_k < x_k$.
	\item Si \underline{$k > j$}: Por como hemos construido la solución voraz, $\sum_{i=1}^{n} p_i y_i > M$, luego este caso no se puede dar. 
\end{itemize}

Modificamos la solución óptima aumentando $y_k$ hasta que $y_k = x_k$ y decrementando los $y_{k+1},\dots,y_n$ de forma que el peso de la mochila siga siendo $M$. Obtenemos así $Z = (z_1,\dots,z_n)$ que cumplirá $z_i = x_i$ para $1\leq i \leq k$. También tendremos, por como hemos modificado $Y$ para conseguir $Z$, que: 
\[\sum_{i=k+1}^{n} p_i(y_i - z_i) = p_k (z_k - y_k) \qquad (*)\]
Finalmente veamos que $Z$ también es óptima. Para ello, como $Y$ lo era, basta ver que no hemos empeorado la situación, es decir, que $\sum_{i=1}^{n} v_i z_i \geq \sum_{i=1}^{n} v_i y_i$:

\[
\begin{split}
	\sum_{i=1}^{n} v_i z_i &= \sum_{i=1}^{n} v_i y_i + v_k(z_k - y_k) - \sum_{i=k+1}^{n} v_i(y_i - z_i) = \\
	& = \sum_{i=1}^{n} v_i y_i + \frac{v_k}{p_k}p_k(z_k - y_k) - \sum_{i=k+1}^{n} \frac{v_i}{p_i}p_i(y_i - z_i) \stackrel{\frac{v_k}{p_k} \geq \frac{v_i}{p_i} \implies -\frac{v_i}{p_i} \geq - \frac{v_k}{p_k}} \geq \\
	& \geq \sum_{i=1}^{n} v_i y_i + (p_k(z_k - y_k) - \sum_{i=k+1}^{n} p_i(y_i - z_i)) \frac{v_k}{p_k} \overset{(*)}{=} \\
	& = \sum_{i=1}^{n} v_i y_i
\end{split}
\]

\subsubsection{Código}

\lstinputlisting[firstline=29, lastline=70]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

\subsubsection{Análisis de costes}

Analizaremos ahora los costes en tiempo y memoria del algoritmo. En cuanto al tiempo tenemos un coste medio $O(n \log(n))$, donde $n$ es el número de objetos, que viene dado por la ordenación de las densidades. Los dos bucles son de coste lineal y el resto de operaciones son constantes. En cuanto al espacio usamos un vector de tamaño $n$ para almacenar las densidades pero como es del orden del tamaño de los datos obtenemos un coste en memoria de $O(1)$.

\subsection{Programación dinámica}

En este apartado implementaremos un algoritmo de programación dinámica para el problema de la mochila en su versión 0-1. Obtendremos una solución exponencial con respecto al tamaño de los datos de entrada.

\subsubsection{Descripción de la solución}

Veamos la forma de abordar el problema desde el punto de vista de la programación dinámica. Primero definimos la función:
\begin{description}
\item \textit{mochila(i, j)} = máximo valor que podemos poner en la mochila de peso máximo j considerando los objetos del 1 al i.
\end{description}

Tomamos como casos base:
\[
\begin{split}
mochila(0, j) &= 0 \qquad 0 \leq j \leq M\\
mochila(i, 0) &= 0 \qquad 0 \leq i \leq n\\
\end{split}
\]
Y como función recursiva:
\[
mochila(i, j) = \twopartdef{mochila(i-1, j)}{p_i > j}{\max \{mochila(i-1, j), mochila(i-1, j-p_i)+v_i\}}{p_i \leq j}
\]
Así pues vamos probando cada objeto y si no cabe no lo cogemos, pero si cabe tomamos el máximo entre cogerlo y no cogerlo. Para ello recorremos la tabla por filas de forma ascendente (cada vez el intervalo $[0, i]$ es más grande) y cada fila la recorremos también de forma ascendente (cada vez la mochila soporta un peso mayor $j$ hasta llegar a $M$). De esta forma el valor que buscamos lo tendremos en la posición $(n, M)$.\\

Para calcular qué objetos hemos cogido una vez que hemos obtenido la solución haremos el proceso inverso. Recorreremos las filas de forma descendente y para cada objeto comprobaremos si lo hemos cogido o no.

TODO (AÑADIR IMAGEN DE LA TABLA!!!!!!!!!!!!!!!)

\subsubsection{Código}

\lstinputlisting[firstline=72, lastline=118]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

\subsubsection{Análisis de costes}

Vemos los costes en tiempo y memoria del algoritmo. En cuanto al tiempo tenemos un coste $O(nM)$, donde $n$ es el numero de objetos. Esto lo obtenemos al recorrer la tabla (de tamaño $nxM$) realizando operaciones constantes en cada posición. El coste de recuperar los objetos seleccionados será lineal en $n$ así que no empeora el orden que ya tenemos. En cuanto a la memoria tenemos un coste $O(nM)$ dado también por la tabla. Aunque pueda parecer que estamos ante un algoritmo polinómico, en realidad tenemos un coste exponencial con respecto al tamaño de los datos de entrada. Esto se debe a que $M$ es un número que representaremos en una cierta base $d$ y esta representación, $\log_d(M)$, es exponencial frente a $M$.

\subsection{Ramificación y poda}

En este apartado implementaremos un algoritmo de ramificación y poda para resolver el problema de la mochila en la versión 0-1. Al igual que en programación dinámica, obtendremos un coste exponencial ($O(n2^n)$).

\subsubsection{Descripción de la solución}

TODO (AÑADIR IMAGEN DEL ESQUEMA DEL ARBOL!!!!!!!!!!!!!!!!!!!!!!!!!)

A la hora de abordar el problema desde el punto de vista de la ramificación y poda seguiremos el esquema optimista/pesimista. La cola de prioridad donde iremos introduciendo los nodos será de máximos y tomaremos como prioridad el valor óptimo que calculemos. Así, la estructura de cada nodo será la siguiente: 

\lstinputlisting[firstline=122, lastline=132]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

Para el nodo $X$ se cumplirá: \[valorOpt(X) \geq valorFinal(X) \geq valorPes(X)\]
donde $valorFinal(X)$ será el valor que tendrá la mochila en la mejor solución alcanzable desde $X$. Además para cualquier solución $Y$ a la que podamos llegar desde $X$ se cumple que: \[valorOpt(X) \geq valorFinal(X) \geq valor(Y)\]

A la hora de calcular $valorOpt(X)$, como el problema es de maximización, tendremos que calcular una cota superior de la mejor solución alcanzable. Para ello utilizaremos el algoritmo voraz que resuelve el problema cuando los objetos se pueden partir. Como esa solución es óptima y tiene menos restricciones que la solución 0-1, no puede haber ninguna solución sin fraccionar objetos que sea mejor.\\

Para $valorPes(X)$ completaremos una posible solución. Incorporaremos a la mochila todos los objetos que se pueda sobre los que todavía no hayamos decidido. Para ello los tomaremos en el orden del algoritmo voraz.

\subsubsection{Código}

\lstinputlisting[firstline=133, lastline=247]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

\subsubsection{Análisis de costes}

Analizaremos ahora los costes en tiempo y memoria del algoritmo. En cuanto al tiempo tendremos un coste en el caso peor $O(n2^n)$, donde $n$ es el número de objetos. Cada iteración del bucle tendrá un coste lineal en $n$ y el bucle se realizará en el caso peor $2^n$ veces. Esto lo podemos razonar desde la estructura de árbol binario que se va generando. En cuanto al coste en espacio tenemos un coste lineal en $n$ por cada nodo y a lo sumo $2^{n-1}$ nodos ya que cada vez vamos sacando uno de la cola de prioridad. Luego el coste en memoria es también de $O(n2^n)$.

\subsection{Algoritmo genético}

En este apartado implementaremos un algoritmo genético para resolver el problema de la mochila 0-1. Al tratarse de un algoritmo heurístico no se asegura una solución óptima aunque generalmente obtendremos una buena solución en un tiempo razonable.

\subsubsection{Descripción de la solución}

Veamos las estructuras y las funciones que hemos tomado a la hora de implementar el algoritmo genético. Representaremos cada solución como un cromosoma que contendrá el vector de soluciones y su valor asociado. Como estamos tratando de maximizar el valor de la mochila, un cromosoma será mejor que otro si su valor es mayor. Más adelante necesitaremos también ordenar toda la población y lo haremos mediante un vector auxiliar de índices así que implementamos también una estructura comparadora.

TODO AÑADIR CROMOSOMA, EL MENOR DE CROMOSOMA Y INDCOMPVALOR

A la hora de calcular la aptitud de un cromosoma calcularemos el valor total de los objetos que tiene. Como tenemos que tener en cuenta la restricción de que el total de los pesos de la mochila no puede superar el peso máximo $M$, será aquí donde impongamos esto. Si una solución de las que hemos obtenido al inicio o después de un cruce o mutación supera en peso a $M$, iremos quitando objetos de manera aleatoria hasta que cumplamos dicha condición. Para inicializar la población lo haremos de manera aleatoria.

TODO AÑADIR APTITUD E INICIALIZACION

Estudiemos la elección de los cromosomas a cruzarse para obtener la siguiente generación. La idea básica detrás de lo que vamos a hacer es escoger con una probabilidad mayor los mejores cromosomas (para que el algoritmo converja más rápido), pero sin dejar de lado los menos aptos (para evitar converger en un mínimo local). Además utilizaremos elitismo, es decir, un porcentaje de los mejores cromosomas se cruzarán siempre. De esta forma nos aseguramos de que no perdemos los mejores candidatos que tenemos por el momento.

De esta forma primero ordenaremos la población, luego aplicaremos elitismo y finalmente completaremos el conjunto de los cromosomas seleccionando de forma aleatoria. Para elegir con mayor probabilidad los mejores dividiremos la población en cuatro intervalos y seleccionaremos de forma ponderada individuos de cada intervalo. Cabe destacar que se puede seleccionar un cromosoma más de una vez.

TODO AÑADIR SELECCION

Veamos como haremos los cruces y las mutaciones de los individuos seleccionados. Sólo se cruzarán un porcentaje, que tomaremos alto, de los cromosomas y de esta manera algunos se transmitirán intactos a la siguiente generación. Para cruzar los cromosomas los iremos cogiendo por parejas, escogeremos un punto aleatorio de la cadena del cromosoma e intercambiaremos la información a partir de dicho punto. Las mutaciones se harán sólo en un porcentaje muy bajo de los individuos. Si un cromosoma debe mutarse, invertiremos de forma aleatoria de 1 a 3 elementos (si antes un objeto se cogía ahora no y viceversa).

TODO AÑADIR CRUCE Y MUTACIÓN 

TODO...

\subsubsection{Código}

\lstinputlisting[firstline=251, lastline=573]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

\subsubsection{Análisis de costes}

\section{Comparación}

% Bibliografía.
%-------------------------------------------------------
\begin{thebibliography}{9}

%Transparencias de algoritmos voraces de clase	

%Wikipedia

%Trabajo del primer cuatri

% Pagina implementacion genetica

%\bibitem{Cd94} Autor, \emph{Título}, Revista/Editor, (año)

\end{thebibliography}

\end{document}