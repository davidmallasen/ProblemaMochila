\documentclass[12pt, a4paper]{article}

%Esto es para poder escribir acentos directamente:
\usepackage[latin1]{inputenc}
%Esto es para que el LaTeX sepa que el texto está en español:
\usepackage[spanish]{babel}

%Paquetes de la AMS:
\usepackage{amsmath}
\usepackage{amsfonts}

%Para añadir imagenes
\usepackage{graphicx}
\graphicspath{ {imagenes/} }

%Hipervinculos
\usepackage{hyperref}

%Para añadir código
\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}

\lstset{
	language = C++,
	frame = single,
	basicstyle=\scriptsize,
	commentstyle=\color{mygreen},
	numbers=left,
	numberstyle=\tiny\color{mygray},
	keywordstyle=\color{blue},
	morekeywords={std, vector, sort, greater, size_t}
}

%Definiciones
\newcommand{\talque}{\text{ tal que }}

\newcommand{\twopartdef}[4]{
	\left\{
	\begin{array}{ll}
		#1 & \mbox{si } #2 \\
		#3 & \mbox{si } #4 \\
	\end{array}
	\right.
}

%Cabecera --------------------------------------
\title{El problema de la mochila}
\author{David Mallasén Quintana}
\date{}

\begin{document}
	
\maketitle

\begin{abstract}
	Implementación y comparación de diferentes algoritmos para resolver el problema de la mochila en sus distintas variantes. Se incluye una introducción al problema y el código de las resoluciones en C++.
\end{abstract}

\tableofcontents

%Cuerpo ----------------------------------------

\section{Introducción}

\subsection{Descripción del problema y variantes}

El problema de la mochila es un problema de optimización combinatoria, es decir, que busca la mejor solución entre un conjunto finito de posibles soluciones. Supondremos que tenemos una mochila con un peso limitado y que queremos llenarla con una serie de objetos dados por su peso y su valor. El objetivo del problema será maximizar el valor total de los objetos que metamos en la mochila sin exceder el peso máximo.\\

El problema de la mochila es uno de los 21 problemas NP-completos de Richard Karp, lista elaborada en 1972 y perteneciente a su trabajo \textit{Reducibility Among Combinatorial Problems}. Esto surgió como profundización del trabajo de Stephen Cook, quien en 1971 había demostrado uno de los resultados más importantes y pioneros de la complejidad computacional: la NP-completitud del Problema de satisfacibilidad booleana (SAT). El descubrimiento de Karp de que todos estos importantes problemas eran NP-completos motivó el estudio de la NP-completitud y de la indagación en la famosa pregunta de si $P=NP$.

\subsubsection{Definición formal del problema}
Supongamos que tenemos $n$ objetos numerados del $1$ al $n$, cada uno con un peso $p_i > 0$ y un valor $v_i > 0$ para cada $i \in \{1, \dots, n\}$. Tendremos también una mochila que soporta un peso máximo $M > 0$.\\

Definimos la función indicadora $x_i \in \{0, 1\}$ que representará si se ha cogido el objeto $i$ ($x_i = 1$) o no ($x_i = 0$). El problema consiste en maximizar \[\sum_{i=1}^{n} v_i x_i\] con la restricción de $\sum_{i=1}^{n} p_i x_i < M$. La solución del problema vendrá dada por el conjunto de las $x_i$.\\

El caso en el que todos los objetos caben juntos en la mochila no tiene mucho interés ya que la solución consistiría en añadirlos todos. Por tanto consideraremos el caso en el que $\sum_{i=1}^{n} p_i > M$.\\

Para el método voraz que veremos en la sección \ref{sec:voraz} tomaremos la variante en que los objetos se pueden fraccionar, es decir, $x_i \in [0, 1]$. En este caso siempre obtendremos una solución óptima, lo demostraremos en \ref{sec:demOptVoraz}, en la que $\sum_{i=1}^{n} p_i x_i = M$.

\subsection{Desarrollo de los casos de prueba}

Incluir breve explicación sobre cómo se desarrollarán los casos de prueba. Inicialización de los valores, tamaño de los casos, cómputo de los tiempos y código de las llamadas.

\section{Implementación de los algoritmos}

\subsection{Método voraz} \label{sec:voraz}

En este apartado implementaremos una solución voraz al problema de la mochila. En el caso del método voraz obtendremos una solución muy eficiente ($O(n\log n)$). Sin embargo tendremos que imponer la restricción de que los objetos sean fraccionables para que podamos asegurar una solución óptima.

\subsubsection{Descripción de la solución}

Primero ordenaremos los objetos según su densidad $d_i = \frac{v_i}{p_i}$. A la hora de construir la solución iremos cogiendo los objetos enteros en orden decreciente de densidad mientras quepan. Finalmente, si sobra hueco, fraccionaremos el objeto de mayor densidad que nos quede para terminar de rellenar toda la mochila.

\subsubsection{Demostración de optimalidad} \label{sec:demOptVoraz}

Sea $X=(x_1,\dots,x_n)$ la solución construida por el algoritmo voraz como hemos indicado anteriormente. Como hemos supuesto al principio que $\sum_{i=1}^{n} p_i > M$,  $\exists j \in \{1,\dots,n\} \talque x_j < 1$. Por la forma en la que construimos la solución sabemos que $0 \leq x_j < 1$ y $x_i = \twopartdef{1}{i < j}{0}{i > j}$. Supongamos que la solución $X$ no es óptima y procedamos mediante el método de reducción de diferencias. Comparamos con una solución óptima $Y = (y_1,\dots,y_n)$. \\

Sea $k = \min \{i:y_i \neq x_i\}$. Por como funciona el algoritmo se debe cumplir que $k \leq j$, veamos que $y_k < x_k$:
\begin{itemize}
	\item Si \underline{$k < j$}: $x_k = 1$ y, por tanto, $y_k < x_k$.
	\item Si \underline{$k = j$}: $y_i = 1$ para $1 \leq i < k$ por lo que $y_k > x_k$ implicaría $\sum_{i=1}^{n} p_i y_i > M$, cosa que no puede suceder. Por como hemos elegido $k$, $y_k \neq x_k$, luego debe ser $y_k < x_k$.
	\item Si \underline{$k > j$}: Por como hemos construido la solución voraz, $\sum_{i=1}^{n} p_i y_i > M$, luego este caso no se puede dar. 
\end{itemize}

Modificamos la solución óptima aumentando $y_k$ hasta que $y_k = x_k$ y decrementando los $y_{k+1},\dots,y_n$ de forma que el peso de la mochila siga siendo $M$. Obtenemos así $Z = (z_1,\dots,z_n)$ que cumplirá $z_i = x_i$ para $1\leq i \leq k$. También tendremos, por como hemos modificado $Y$ para conseguir $Z$, que: 
\[\sum_{i=k+1}^{n} p_i(y_i - z_i) = p_k (z_k - y_k) \qquad (*)\]
Finalmente veamos que $Z$ también es óptima. Para ello, como $Y$ lo era, basta ver que no hemos empeorado la situación, es decir, que $\sum_{i=1}^{n} v_i z_i \geq \sum_{i=1}^{n} v_i y_i$:

\[
\begin{split}
	\sum_{i=1}^{n} v_i z_i &= \sum_{i=1}^{n} v_i y_i + v_k(z_k - y_k) - \sum_{i=k+1}^{n} v_i(y_i - z_i) = \\
	& = \sum_{i=1}^{n} v_i y_i + \frac{v_k}{p_k}p_k(z_k - y_k) - \sum_{i=k+1}^{n} \frac{v_i}{p_i}p_i(y_i - z_i) \stackrel{\frac{v_k}{p_k} \geq \frac{v_i}{p_i} \implies -\frac{v_i}{p_i} \geq - \frac{v_k}{p_k}} \geq \\
	& \geq \sum_{i=1}^{n} v_i y_i + (p_k(z_k - y_k) - \sum_{i=k+1}^{n} p_i(y_i - z_i)) \frac{v_k}{p_k} \overset{(*)}{=} \\
	& = \sum_{i=1}^{n} v_i y_i
\end{split}
\]

\subsubsection{Código}

\lstinputlisting[firstline=31, lastline=70]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

\subsubsection{Análisis de costes}

Analizaremos ahora los costes en tiempo y memoria del algoritmo. En cuanto al tiempo tenemos un coste medio $O(n \log n)$, donde $n$ es el número de objetos, que viene dado por la ordenación de las densidades. Los dos bucles son de coste lineal y el resto de operaciones son constantes. En cuanto al espacio usamos un vector de tamaño $n$ para almacenar las densidades pero como es del orden del tamaño de los datos obtenemos un coste en memoria de $O(1)$.

\subsection{Programación dinámica}

En este apartado implementaremos un algoritmo de programación dinámica para el problema de la mochila en su versión 0-1. Tendremos que tener la restricción de que los pesos de los objetos y el peso total de la mochila sean números enteros. Sin embargo esto no supone una restricción real para el algoritmo ya que, siempre que los pesos sean números racionales, podremos multiplicar todos los pesos por una constante para que resulten en números enteros (por ejemplo, suponiendo los pesos escritos como fracciones, por el mínimo común múltiplo de los denominadores). Con este algoritmo obtendremos una solución exponencial con respecto al tamaño de los datos de entrada.

\subsubsection{Descripción de la solución}

Veamos la forma de abordar el problema desde el punto de vista de la programación dinámica. Primero definimos la función:
\begin{description}
\item \textit{mochila(i, j)} = máximo valor que podemos poner en la mochila de peso máximo $j$ considerando los objetos del $1$ al $i$.
\end{description}

Tomamos como casos base:
\[
\begin{split}
mochila(0, j) &= 0 \qquad 0 \leq j \leq M\\
mochila(i, 0) &= 0 \qquad 0 \leq i \leq n\\
\end{split}
\]
Y como función recursiva:
\[
mochila(i, j) = \twopartdef{mochila(i-1, j)}{p_i > j}{\max \{mochila(i-1, j), mochila(i-1, j-p_i)+v_i\}}{p_i \leq j}
\]
Así pues vamos probando cada objeto y si no cabe no lo cogemos, pero si cabe tomamos el máximo entre cogerlo y no cogerlo. Para ello recorremos la tabla por filas de forma ascendente (cada vez el intervalo $[0, i]$ es más grande) y cada fila la recorremos también de forma ascendente (cada vez la mochila soporta un peso mayor $j$ hasta llegar a $M$). De esta forma el valor que buscamos lo tendremos en la posición $(n, M)$.

\begin{figure}[h]
\includegraphics[scale=0.5]{tablaProgDin}
\centering
\end{figure}

Para calcular qué objetos hemos cogido una vez que hemos obtenido la solución haremos el proceso inverso. Recorreremos las filas de forma descendente y para cada objeto comprobaremos si lo hemos cogido o no.

\subsubsection{Código}

\lstinputlisting[firstline=74, lastline=119]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

\subsubsection{Análisis de costes}

Vemos los costes en tiempo y memoria del algoritmo. En cuanto al tiempo tenemos un coste $O(nM)$, donde $n$ es el numero de objetos. Esto lo obtenemos al recorrer la tabla (de tamaño $nxM$) realizando operaciones constantes en cada posición. El coste de recuperar los objetos seleccionados será lineal en $n$ así que no empeora el orden que ya tenemos. En cuanto a la memoria tenemos un coste $O(nM)$ dado también por la tabla. Aunque pueda parecer que estamos ante un algoritmo polinómico, en realidad tenemos un coste exponencial con respecto al tamaño de los datos de entrada. Esto se debe a que $M$ es un número que representaremos en una cierta base $d$ y esta representación, $\log_d(M)$, es exponencial frente a $M$.

\subsection{Ramificación y poda}

En este apartado implementaremos un algoritmo de ramificación y poda para resolver el problema de la mochila en la versión 0-1. Al igual que en programación dinámica, obtendremos un coste exponencial ($O(n2^n)$).

\subsubsection{Descripción de la solución}

A la hora de resolver el problema desde el punto de vista de la programación dinámica, tomaremos un árbol de decisiones binario que represente si se coge o no cada objeto.

\begin{figure}[h]
	\includegraphics[scale=0.5]{arbolRamPoda}
	\centering
\end{figure}

A partir de esto seguiremos el esquema optimista/pesimista. La cola de prioridad donde iremos introduciendo los nodos será de máximos y tomaremos como prioridad el valor óptimo que calculemos. Así, la estructura de cada nodo será la siguiente: 

\lstinputlisting[firstline=123, lastline=132]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

Para el nodo $X$ se cumplirá: \[valorOpt(X) \geq valorFinal(X) \geq valorPes(X)\]
donde $valorFinal(X)$ será el valor que tendrá la mochila en la mejor solución alcanzable desde $X$. Además, para cualquier solución $Y$ a la que podamos llegar desde $X$ se cumple que: \[valorOpt(X) \geq valorFinal(X) \geq valor(Y)\]

A la hora de calcular $valorOpt(X)$, como el problema es de maximización, tendremos que calcular una cota superior de la mejor solución alcanzable. Para ello utilizaremos el algoritmo voraz que resuelve el problema cuando los objetos se pueden partir. Como esa solución es óptima y tiene menos restricciones que la solución 0-1, no puede haber ninguna solución sin fraccionar objetos que sea mejor.\\

Para $valorPes(X)$ completaremos una posible solución. Incorporaremos a la mochila todos los objetos que se pueda sobre los que todavía no hayamos decidido. Para ello los tomaremos en el orden del algoritmo voraz.

\subsubsection{Código}

\lstinputlisting[firstline=134, lastline=249]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

\subsubsection{Análisis de costes}

Analizaremos ahora los costes en tiempo y memoria del algoritmo. En cuanto al tiempo tendremos un coste en el caso peor $O(n2^n)$, donde $n$ es el número de objetos. Cada iteración del bucle tendrá un coste lineal en $n$ y el bucle se realizará en el caso peor $2^n$ veces. Esto lo podemos razonar desde la estructura de árbol binario que se va generando. En cuanto al coste en espacio tenemos un coste lineal en $n$ por cada nodo y a lo sumo $2^{n-1}$ nodos ya que cada vez vamos sacando uno de la cola de prioridad y hay como mucho $2^{n-1}$ hojas. Luego el coste en memoria es también de $O(n2^n)$.

\subsection{Algoritmo genético}

En este apartado implementaremos un algoritmo genético para resolver el problema de la mochila 0-1. Al tratarse de un algoritmo heurístico no se asegura una solución óptima aunque generalmente obtendremos una buena solución en un tiempo razonable.

\subsubsection{Descripción de la solución y código de las funciones}

Veamos las estructuras y las funciones que hemos utilizado a la hora de implementar el algoritmo genético. Representaremos cada solución como un cromosoma que contendrá el vector de soluciones y su valor asociado. Como estamos tratando de maximizar el valor de la mochila, un cromosoma será mejor que otro si su valor es mayor. Más adelante necesitaremos también ordenar toda la población y lo haremos mediante un vector auxiliar de índices así que implementamos también una estructura comparadora.

\lstinputlisting[firstline=253, lastline=272]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

A la hora de calcular la aptitud de un cromosoma calcularemos el valor total de los objetos que tiene. Como tenemos que tener en cuenta la restricción de que el total de los pesos de la mochila no puede superar el peso máximo $M$, será aquí donde impongamos esto. Si una solución de las que hemos obtenido al inicio o después de un cruce o mutación supera en peso a $M$, iremos quitando objetos de manera aleatoria hasta que cumplamos dicha condición. Para inicializar la población lo haremos de manera aleatoria.

\lstinputlisting[firstline=283, lastline=334]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

Estudiemos la elección de los cromosomas a cruzarse para obtener la siguiente generación. La idea básica detrás de lo que vamos a hacer es escoger con una probabilidad mayor los mejores cromosomas (para que el algoritmo converja más rápido), pero sin dejar de lado los menos aptos (para evitar converger en un mínimo local). Además utilizaremos elitismo, es decir, un porcentaje de los mejores cromosomas se cruzarán siempre. De esta forma nos aseguramos de que no perdemos los mejores candidatos que tenemos por el momento.\\

Así, primero ordenaremos la población, luego aplicaremos elitismo y finalmente completaremos el conjunto de los cromosomas seleccionando de forma aleatoria. Para elegir con mayor probabilidad los mejores candidatos dividiremos la población en cuatro intervalos y seleccionaremos de forma ponderada individuos de cada intervalo. Cabe destacar que se puede seleccionar un cromosoma más de una vez.

\lstinputlisting[firstline=336, lastline=377]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

Veamos como haremos los cruces y las mutaciones de los individuos seleccionados. Sólo se cruzarán un porcentaje, que tomaremos alto, de los cromosomas, y de esta manera algunos se transmitirán intactos a la siguiente generación. Para cruzar los cromosomas los iremos cogiendo por parejas, escogeremos un punto aleatorio de la cadena del cromosoma e intercambiaremos la información a partir de dicho punto. Las mutaciones se harán sólo en un porcentaje muy bajo de los individuos. Si un cromosoma debe mutarse, invertiremos de forma aleatoria de 1 a 3 elementos (si antes un objeto se cogía ahora no y viceversa).

\lstinputlisting[firstline=379, lastline=426]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

Como condición de terminación iremos comprobando si se ha mejorado la mejor solución que teníamos hasta el momento o la media de la población en alguna de las últimas generaciones. Si se ha mejorado alguna de ambas se seguirá con la ejecución y sino terminará. Añadiremos también un máximo de generaciones tras las cuales el algoritmo se detendrá aunque no se cumpla la condición anterior.

\lstinputlisting[firstline=428, lastline=461]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

Utilizaremos una función auxiliar para actualizar los valores de la mejor solución que tenemos y las medias que usamos en la condición de parada.

\lstinputlisting[firstline=463, lastline=503]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

Finalmente nuestro programa principal será el encargado de inicializar la población e ir evolucionando las sucesivas generaciones hasta que se cumpla la condición de terminación. Devolverá como parámetro el mejor valor que hayamos encontrado en todas las generaciones y los objetos que componían la mochila para ese valor.

\subsubsection{Código}

\lstinputlisting[firstline=505, lastline=552]{../ProblemaMochilaCpp/ProblemaMochila.cpp}

\subsubsection{Análisis de costes}

Analizaremos ahora los costes en tiempo y memoria del algoritmo. Veamos primero el coste en espacio: Guardaremos la población actual y los cromosomas seleccionados para formar parte de la siguiente, luego tendremos un coste $O(m)$ respecto a los datos de entrada (tenemos un vector de $n$ objetos), siendo $m$ el tamaño de la población que elijamos.\\

En cuanto al coste en tiempo, se trata de un algoritmo heurístico que en el caso peor terminará cuando complete el máximo de generaciones. Luego llamando $n$ al numero de objetos, $m$ al tamaño que elijamos de la población y $g$ al número máximo de generaciones, obtendremos un coste $O(g\max\{nm, n\log n\})$. Justificamos el coste viendo que el bucle se ejecutará un máximo de $g$ veces y cada iteración tiene un coste $\max\{nm, n\log n\}$ dado por las funciones de cruce y selección respectivamente.

\section{Comparación}

Comparativa de tiempos en las ejecuciones de los distintos algoritmos. Analizar diferencias entre programación dinámica y ramificación y poda. Ver que el voraz es mucho más rápido y justificar lo bueno, o no, que puede llegar a ser el algoritmo genético según los resultados.

% Bibliografía.
%-------------------------------------------------------
\begin{thebibliography}{99}
	
\bibitem{horow-sah-raja98} E. Horowitz, S. Sahni y S. Rajasekaran. \emph{Computer Algorithms}. Tercera edición. Computer Science Press, 1998. Capítulos 4, 5 y 8.

\bibitem{hrist-shre04} Hristakeva-Shrestha. \emph{Solving the 0-1 Knapsack Problem with Genetic Algorithms}. Simpson College. \url{http://www.micsymposium.org/mics_2004/Hristake.pdf}

\bibitem{marti-orte-verd03} N. Martí Oliet, Y. Ortega Mallén y J. A. Verdejo López. \emph{Estructuras de datos y métodos algorítmicos: ejercicios resueltos}. Colección Prentice Practica, Pearson/Prentice Hall, 2003. Capítulo 13.

\bibitem{marti-orte-verd13} N. Martí Oliet, Y. Ortega Mallén y A. Verdejo. \emph{Estructuras de datos y métodos algorítmicos: 213 ejercicios resueltos}. Segunda edición. Garceta, 2013. Capítulos 12 y 15.

\bibitem{micha95} Z. Michalewicz. \emph{Genetic Algorithms + Data Structures = Evolution Programs}. Third, revised and extended edition. Springer, 1995.

\bibitem{mitch99} M. Mitchell. \emph{An Introduction to Genetic Algorithms}. Fifth printing. The MIT Press, 1999.

\bibitem{neap15} R. Neapolitan. \emph{Foundations of Algorithms}. Quinta edición. Jones and Barlett, 2015. Capítulos 4 y 10.

\bibitem{neap-naim04} R. Neapolitan y K. Naimipour. \emph{Foundations of Algorithms using C++ pseudocode}. Jones and Barlett Publishers, 2004. Capítulos 3 y 6.

\bibitem{wikipedia} Artículos de la enciclopedia libre Wikipedia:
\begin{itemize}
	\item Problema de la mochila:\\ \url{https://es.wikipedia.org/wiki/Problema_de_la_mochila}
	\item Lista de 21 problemas NP-completos de Karp:\\ \url{https://es.wikipedia.org/wiki/Lista_de_21_problemas_NP-completos_de_Karp}
	\item Algoritmos genéticos:\\ \url{https://en.wikipedia.org/wiki/Genetic_algorithm}
\end{itemize}

\end{thebibliography}

\end{document}